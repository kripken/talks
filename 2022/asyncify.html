<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Asyncify in Practice</title>

    <meta name="description" content="Asyncify in Practice">
    <meta name="author" content="Alon Zakai">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/white.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h2>Asyncify in Practice</h2>
          <p>
            Alon Zakai
          </p>
          <p>
            Jan 2022
          </p>
          <p>
            Wasm Stack Switching Subgroup
          </p>
        </section>

        <section>
          <h3>
            Goals
          </h3>
          <p>
            <ul>
              <li>Overview of Asyncify</li>
              <li>How it is used</li>
              <li>Lessons from those experiences</li>
            </ul>
          </p>
        </section>

        <section>
          <h3>
            WebAssembly has a simple execution model
          </h3>
          <p>
            1. Synchronous code executes synchronously.
          </p>
          <pre><code class="lisp">
;; this completes fully before the next line
(call $something-async)
(call $after)
          </code></pre>
        </section>

        <section>
          <pre><code class="js">
// source code compiled to wasm
fread(buffer, 1, num, file);
// the data is ready to be used right here, synchronously
          </code></pre>
          But on the Web,
          <pre><code class="js">
const result = fetch("http://example.com/data.dat");
// result is a Promise; the data is not ready yet!
          </code></pre>
          ðŸ˜”
          <p>
            As a workaround, can preload/embed files.
          </p>
        </section>

        <section>
          <p>
            2. The call stack and locals are not visible in "userspace".
          </p>
          <pre><code class="lisp">
(func $foo
  (local $x i32)
  (local $y i32)
  (local $z i32)
  ..
  ;; no way to observe all the local values here,
  ;; or calls up the stack
  (call $conservative-gc)
)
          </code></pre>
        </section>

        <section>
          <p>
            As a workaround, on the Web you can do a GC when <b>nothing is on the stack</b>
            which, outside of a Worker, must happen repeatedly.
          </p>
          <hr>
          <p>
            But that does not help various use cases:
            ðŸ˜”
            <ul>
              <li>Workers with no pauses</li>
              <li>many allocations in a single event</li>
              <li>off the Web</li>
            </ul>
          </p>
         </section>

        <section>
          <h3>The solution</h3>
          <p>
            WebAssembly support for stack switching and stack walking! ðŸš€
          </p>
          <hr>
          <p>
            But we need something while we wait...
          </p>
        </section>

        <section>
          <h3>Asyncify</h3>
          <p>
            Asyncify is a <b>transformation</b> that can be run on a wasm module.
            It adds support for <b>unwinding</b> and <b>rewinding</b> the call stack.
          </p>
          <hr>
          <p>
            Asyncify is implemented as a generic
            <a href="https://github.com/WebAssembly/binaryen/blob/main/src/passes/Asyncify.cpp">Binaryen pass</a>
            (not specific to any particular toolchain)
            and running it is as easy as
          </p>
          <pre><code class="shell">
wasm-opt input.wasm --asyncify -O -o output.wasm
          </code></pre>
        </section>

        <section>
          <h3>The Asyncify API</h3>
          <pre><code class="lisp">
(import "asyncify" "start_unwind"
    (func $asyncify_start_unwind (param i32)))

(import "asyncify" "stop_unwind"
    (func $asyncify_stop_unwind))

(import "asyncify" "start_rewind"
    (func $asyncify_start_rewind (param i32)))

(import "asyncify" "stop_rewind"
    (func $asyncify_stop_rewind))
          </code></pre>
          <p>
            The parameter refers to a buffer in linear memory, used to store
            the serialized call stack and locals.
          </p>
        </section>

        <section>
          <p>
            Simply call "<b>start unwind</b>" from any point in the program, then
            "<b>stop unwind</b>" when you reach the point you want to stop at.
          </p>
          <hr>
          <p>
            Later, call "<b>start rewind</b>". Then call the first function on
            the previous call stack, which begins the rewind, ending
            up where it was "paused" before. When you get there, call "<b>stop rewind</b>".
          </p>
          <hr>
          <p>That's it!</p>
        </section>

        <section>
          <p>
            Example:
          </p>
          <pre><code class="lisp" data-trim>
(func $sleep
  (if
    (i32.eqz (global.get $sleeping))
    (block
      ;; Start to sleep.
      (global.set $sleeping (i32.const 1))
      (i32.store (i32.const 16) (i32.const 24))    ;; define
      (i32.store (i32.const 20) (i32.const 1024))  ;; stack
      (call $asyncify_start_unwind (i32.const 16)));; info
    (block
      ;; Resume after sleep, when we are called the 2nd time
      (call $asyncify_stop_rewind)
      (global.set $sleeping (i32.const 0)))))
          </code></pre>
        </section>

        <section>
          <pre><code class="lisp" data-trim>
  (func $main
    (call $print (i32.const 1))
    (call $sleep)
    (call $print (i32.const 3)))
  (func $runtime
    ;; Call main the first time, let the stack unwind.
    (call $main)
    (call $asyncify_stop_unwind)
    ;; We could do anything we want around here while
    ;; the code is paused!
    (call $print (i32.const 2))
    ;; Set the rewind in motion.
    (call $asyncify_start_rewind (i32.const 16))
    (call $main))
          </code></pre>
          <p>
            The key idea is what we call main <b>twice</b>, the second time to
            start to rewind.
          </p>
        </section>

        <section>
          <h3>Using Asyncify in Practice</h3>
          <p>
            By default, <b>50% or so code size and speed downside</b>. (However,
            the worst case can be far worse.)
          </p>
          <hr>
          <p>
            This ~50% is achieved by avoiding instrumentation where the
            optimizer can prove it is not needed.
          </p>
          <hr>
          <p>
            With manual listing of relevant functions, can reduce overhead
            a lot more in many cases.
          </p>
        </section>

        <section>
          <h3>More on Speed</h3>
          <p>
            Splitting functions into pieces (CPS-style) is one way to implement
            pause/resume. Asyncify takes a different approach because of wasm's
            nature:
          </p>
          <p>
            <ul>
              <li><b>Structured control flow</b></li>
              <li><b>Code size is critical</b></li>
              <li><b>Indirect calls are slow</b></li>
            </ul>
          </p>
          <p>
            Asyncify preserves wasm structure and adds instrumention on top.
          </p>
        </section>

        <section>
          <pre><code class="js" data-trim>
// conceptual code
function foo() {
  if (rewinding) { ..restore locals.. }
  unwind: {
    if (!(rewinding && notYet())) {
      call();
      if (unwinding) break unwind;
      ...
    }
    ...
    return;
  }
  ..save locals..
}
          </code></pre>
          <hr>
          <p>
            Those added ifs are often well-predicted branches!
          </p>
        </section>


        <section>
          <h3>Asyncify in production today</h3>
          <h4>
            1. Emscripten
          </h4>
          <hr>
          <p>
            Integration at the JavaScript level. Could use Promise API.
          </p>
          <hr>
          <p>
            Build with <code>-s ASYNCIFY</code>
          </p>
          <hr>
          <p>
            Enabled APIs: <code>emscripten_sleep()</code>,
              <code>emscripten_scan_registers()</code>, etc.
          </p>
          <hr>
          <p>
            Used in e.g. DOSBox, Doom 3, test suites, etc.
          </p>
        </section>

        <section>
          <pre><code class="cpp">
  while (1) {
    // Main game loop
    input();
    physics();
    rendering();
    audio();

    // Necessary on the web!
    emscripten_sleep(0);
  }
          </code></pre>
        </section>

        <section>
          <h3>Asyncify in production today</h3>
          <p>
            2. TinyGo
          </p>
          <hr>
          <p>
            Integration at the Wasm level.
          </p>
          <hr>
          <p>
            Used to <a href="https://twitter.com/TinyGolang/status/1461364896197578759">implement goroutines</a>
          </p>
        </section>

        <section>
          <h3>Asyncify in production today</h3>
          <p>
            3. Ruby's Wasm/WASI port
          </p>
          <hr>
          <p>
            Integration at the Wasm level.
          </p>
          <hr>
          <p>
            Used for
            <a href="https://github.com/WebAssembly/binaryen/issues/4401#issuecomment-1006176967">setjmp/longjmp and conservative stack scanning</a>
            (<a href="https://github.com/ruby/ruby/pull/5407">PR</a>).
        </section>

        <section>
          <h3>Asyncify: original goals vs practice</h3>
          <p>
            As the name shows, the original use case was just the <b>sync/async</b>
            problem.
          </p>
          <hr>
          <p>
            But in practice, <b>setjmp/longjmp</b> as well as <b>conservative GC</b> have
            become important too.
          </p>
        </section>

        <section>
          <h3>More detail: setjmp / longjmp</h3>
          <hr>
          <p>
            A tricky operation, especially in the setjmp()-ing function itself:
          </p>
          <pre><code class="js" data-trim>
function foo() {
  while (1) {
    a();
    if (setjmp()) {
      b();
    } else {
      c();
    }
  }
  if (d()) longjmp(); // into the middle of a loop!
}
          </code></pre>
        </section>

        <section>
          <p>
            Aside from that, we need to <b>unwind</b> back to the setjmp()-ing
            function. Fairly easy to do if you carry around a boolean "am I
            unwinding" at calls, conceptually like this everywhere:
          </p>
          <pre><code class="js" data-trim>
function foo() {
  ...
  result, unwinding = bar();
  if (unwinding) return;
  ...
}
          </code></pre>
        </section>

        <section>
          <p>
            <a href="https://github.com/WebAssembly/exception-handling/blob/main/proposals/exception-handling/Exceptions.md">Wasm exception handling</a>
            and/or stack switching
            will be the proper solution. But what can we do for now?
          </p>
          <hr>
          <p>
            Historically Emscripten relied on <b>LLVM</b> to transform the setjmping
            function, and on <b>JavaScript</b> to provide unwinding (less code size
            without an extra boolean everywhere).
          </p>
          <hr>
          <p>
            But we have lacked a solution for pure Wasm environments like WASI.
          </p>
        </section>

        <section>
          <p>
            I gave a
            <a href="https://www.meetup.com/wasmsf/events/264249894/">wasm meetup</a>
            <a href="https://www.youtube.com/watch?v=qQOP6jqZqf8">talk about Asyncify</a>
            back in 2019, with a demo there of using Asyncify to implement setjmp/longjmp in
            pure wasm:
          </p>
          <hr>
          <p>
            <ul>
              <li><b>pause</b> at the setjmp</li>
              <li><b>resume</b> it immediately</li>
              <li><b>resume it again</b> when longjmp is called</li>
            </ul>
          </p>
          <hr>
          <p>
            Someone from the audience mentioned that it might be
            useful for WASI. Great to see that now used in Ruby in production!
          </p>
        </section>

        <section>
          <h3>More detail: conservative GC</h3>
          <p>
            Pretty simple with Asyncify:
          </p>
          <hr>
          <p>
            <ul>
              <li><b>pause</b></li>
              <li><b>scan</b> the pause/resume buffer, which now contains all the locals up the stack</li>
              <li><b>resume</b></li>
            </ul>
          </p>
          <hr>
          <p>
            Pause/resume adds overhead, but probably ok given how GCs work.
          </p>
        </section>

        <section>
          <h3>Relevance to stack switching</h3>
          <p>
            That people are willing to use Asyncify with the 50% overhead shows
            the need!
          </p>
        </section>

        <section>
          <h3>Relevance to stack switching?</h3>
          <p>
            <b>Multiple resumes</b> (setjmp/longjmp) may not be relevant
            since LLVM + Wasm EH already provide a solution for that. (But maybe other use cases?)
          </p>
        </section>

        <section>
          <h3>Relevance to stack switching?</h3>
          <p>
            <b>Stack scanning</b> (conservative GC) is a separate problem, but perhaps worth thinking
            about how that interacts? E.g. scanning a paused stack may be enough - is that simpler?
          </p>
        </section>

        <section>
          <h3>Relevance: Minimalism</h3>
          <p>
            Asyncify defines only 4 simple, low-level functions:
          </p>
          <hr>
          <p>
            <table>
              <tr>
                <td>start_unwind(buf)</td>
                <td></td>
                <td>stop_unwind()</td>
              </tr>
              <tr>
                <td>start_rewind(buf)</td>
                <td></td>
                <td>stop_rewind()</td>
              </tr>
            </table>
          </p>
          <hr>
          <p>
            The <b>toolchain/VM engineer</b> builds on top of those (e.g. handling
            state, value passing, types, etc.).
          </p>
        </section>

        <section>
          <p>
            This simple API works well in those three very different
            toolchains, <b>Emscripten, TinyGo, and Ruby</b>.
          </p>
          <hr>
          <p>
            That exact API can't work for the spec, but perhaps we can find
            something similarly minimalistic?
          </p>
        </section>

        <section>
          <p>
            Thank you for listening!
          </p>
          <hr>
          <p>
            <b>Questions / thoughts?</b>
          </p>
        </section>

      </div>


    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/zoom/zoom.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/search/search.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>

      // Also available as an ES module, see:
      // https://revealjs.com/initialization/
      Reveal.initialize({
        controls: true,
        progress: true,
        center: true,
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
      });

    </script>

  </body>
</html>
